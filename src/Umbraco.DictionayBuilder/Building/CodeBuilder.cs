using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using Umbraco.DictionaryBuilder.Configuration;
using Umbraco.DictionaryBuilder.Extensions;
using Umbraco.DictionaryBuilder.Models;

namespace Umbraco.DictionaryBuilder.Building
{
    /// <summary>
    /// Implements a builder that works by writing text.
    /// </summary>
    internal class CodeBuilder
    {
        private readonly IDictionaryBuilderConfiguration _config;
        private int _currentIndent;
        private readonly StringBuilder _builder;
        private readonly string _name;
        private readonly string _version;
        
        /// <summary>
        /// Initializes a new instance of the <see cref="CodeBuilder"/> class.
        /// </summary>
        /// <param name="config">A required configuration</param>
        /// <param name="builder">An optionally string builder to append to. If not provided, a new instance will be created.</param>
        internal CodeBuilder(IDictionaryBuilderConfiguration config, StringBuilder builder = null)
        {
            _config = config ?? throw new ArgumentException("Argument is required", nameof(config));
            _builder = builder ?? new StringBuilder();

            AssemblyName assemblyName = GetType().Assembly.GetName();
            _name = assemblyName.Name;
            _version = assemblyName.Version.ToString(3);
        }

        /// <summary>
        /// Write generated models to the string builder.
        /// </summary>
        /// <param name="models">The models to generate.</param>
        public void Generate(params DictionaryModel[] models)
        {
            WriteHeader();
            WriteLine($"using {typeof(DictionaryModel).Namespace};");
            _builder.AppendLine();
            WriteLine($"namespace {_config.DictionaryNamespace}");
            WriteInBrackets(WriteDictionaryItemContainerClass, models);
        }

        /// <summary>
        /// Outputs the content of the string builder.
        /// </summary>
        /// <returns>A string containing the models code</returns>
        public override string ToString()
        {
            return _builder.ToString();
        }

        /// <summary>
        /// Writes an "auto-generated" header to the string builder.
        /// </summary>
        private void WriteHeader()
        {
            _builder.AppendLine("//------------------------------------------------------------------------------");
            _builder.AppendLine("// <auto-generated>");
            _builder.AppendLine("//   This code was generated by a tool.");
            _builder.AppendLine("//");
            _builder.AppendLine($"//    {_name} v{_version}");
            _builder.AppendLine("//");
            _builder.AppendLine("//   Changes to this file will be lost if the code is regenerated.");
            _builder.AppendLine("// </auto-generated>");
            _builder.AppendLine("//------------------------------------------------------------------------------");
            _builder.AppendLine("");
        }

        private void WriteInBrackets(Action<DictionaryModel> action, DictionaryModel model)
        {
            WriteLine("{");
            _currentIndent++;

            action?.Invoke(model);

            _currentIndent--;
            WriteLine("}");
        }

        private void WriteInBrackets(Action<DictionaryModel[]> action, DictionaryModel[] models)
        {
            WriteLine("{");
            _currentIndent++;

            action?.Invoke(models);

            _currentIndent--;
            WriteLine("}");
        }

        /// <summary>
        /// Writes an indented line
        /// </summary>
        /// <param name="content">The content to write</param>
        private void WriteLine(string content)
        {
            string tabs = string.Empty;
            for (int i = 0; i < _currentIndent; i++) 
                tabs += "    ";
            
            _builder.Append(tabs);
            _builder.AppendLine(content);
        }
        
        /// <summary>
        /// Writes a partial class that collects the models inside this class
        /// </summary>
        /// <param name="models">The models to build</param>
        private void WriteDictionaryItemContainerClass(params DictionaryModel[] models)
        {
            WritePartialClass(_config.DictionaryItemsPartialClassName, WriteDictionaries, models);
        }

        /// <summary>
        /// Writes a collection of models
        /// </summary>
        /// <param name="models">The models to build</param>
        private void WriteDictionaries(params DictionaryModel[] models)
        {
            if(models == null)
                return;

            // Iterate through all models
            for (int i = 0; i < models.Length; i++)
            {
                DictionaryModel model = models[i];
                // Write a start region directive
                WriteLine($"#region {model.GetItemKey()}");

                // Create a list of action starting the the action to build the model itself
                List<Action<DictionaryModel>> parentModelActions =
                    new List<Action<DictionaryModel>> {m => WriteContentModel(model)};

                if (model.RenderParentModel(_config.UseNestedStructure))
                {
                    // Get the parent model
                    DictionaryModel parentModel = model.GetParentModel();
                    // Loop through all parent models
                    while (parentModel != null)
                    {
                        // Prevent access to modified closure, so creating a local variable
                        // https://www.jetbrains.com/help/resharper/2020.1/AccessToModifiedClosure.html
                        DictionaryModel localParentModel = parentModel;

                        // The last added action is the child action to this action
                        Action<DictionaryModel> childAction = parentModelActions.Last();
                        // Generate the class name
                        string itemKey = localParentModel.GenerateCodeItemKey(_config.UseNestedStructure);
                        string className = itemKey.ToCodeString(true).ToPascalCase();
                        // Add the action to the list
                        parentModelActions.Add(m => WritePartialClass($"_{className}", childAction, localParentModel));

                        // Get the next parent model
                        parentModel = parentModel.GetParentModel();
                    }
                }

                // Get the root action.
                Action<DictionaryModel> rootAction = parentModelActions.Last();
                // Execute the root action, to start building the nested class structure
                rootAction(model);

                // Write a end region directive
                WriteLine("#endregion");

                // If not the last model, add an empty line
                if(i < models.Length-1)
                    _builder.AppendLine();
            }
        }

        /// <summary>
        /// Writes a partial class, with a single model action
        /// </summary>
        /// <param name="className">The class name</param>
        /// <param name="action">The action that builds the model inside the class</param>
        /// <param name="model">The model to build</param>
        private void WritePartialClass(string className, Action<DictionaryModel> action, DictionaryModel model)
        {
            if(model == null)
                return;

            WriteLine($"public partial class {className}");
            WriteInBrackets(action, model);
        }

        /// <summary>
        /// Writes a partial class, with a multiple models action
        /// </summary>
        /// <param name="className">The class name</param>
        /// <param name="action">The action that builds the models inside the class</param>
        /// <param name="models">The models to build</param>
        private void WritePartialClass(string className, Action<DictionaryModel[]> action, params DictionaryModel[] models)
        {
            if(models == null)
                return;

            WriteLine($"public partial class {className}");
            WriteInBrackets(action, models);
        }

        private void WriteContentModel(DictionaryModel model)
        {
            if(model == null)
                return;

            string itemKey = model.GenerateCodeItemKey(_config.UseNestedStructure);

            // Generate class name
            string className = itemKey.ToCodeString(true).ToPascalCase();
            // Generate field name
            string fieldName = itemKey.ToCodeString(false).ToCamelCase();

            // Write generated code attribute to prevent warnings
            WriteGeneratedCodeAttribute();
            // Write the static field
            WriteLine($"private static _{className} _{fieldName} = new _{className}();");
            
            // Write an empty line
            _builder.AppendLine();

            // Write the property
            WriteSummary($"The dictionary item: [{model.GetItemKey()}]");
            // Write generated code attribute to prevent warnings
            WriteGeneratedCodeAttribute();
            // If the model is the root model, then add static modifier to the property. Otherwise the property is initialized in the nested class structure
            WriteLine($"public{(model.IsRootModel(_config.UseNestedStructure) ? " static" : "")} _{className} {className} => _{fieldName};");

            // Write an empty line
            _builder.AppendLine();

            // Write the nested DictionaryItem class
            WriteLine($"public partial class _{className} : {nameof(DictionaryModel)}");
            WriteInBrackets(WriteConstructor, model);
        }

        /// <summary>
        /// Writes a constructor, that calls the base <see cref="DictionaryModel"/>'s constructor with the ItemKey 
        /// </summary>
        /// <param name="model"></param>
        private void WriteConstructor(DictionaryModel model)
        {
            string itemKey = model.GenerateCodeItemKey(_config.UseNestedStructure);
            string className = itemKey.ToCodeString(true).ToPascalCase();
            WriteLine($"public _{className}() : base(\"{model.GetItemKey()}\") {{}}");
        }

        /// <summary>
        /// Write a summary comment
        /// </summary>
        /// <param name="summary">The summary text</param>
        private void WriteSummary(string summary)
        {
            WriteLine("/// <summary>");
            WriteLine($"/// {summary}");
            WriteLine("/// </summary>");
        }

        /// <summary>
        /// Writes an attribute that identifies code generated by a tool
        /// (helps reduce warnings, tools such as FxCop use it)
        /// </summary>
        /// <remarks>
        /// See https://docs.microsoft.com/en-us/dotnet/api/system.codedom.compiler.generatedcodeattribute <br/>
        /// See https://blogs.msdn.microsoft.com/codeanalysis/2007/04/27/correct-usage-of-the-compilergeneratedattribute-and-the-generatedcodeattribute/ <br/>
        /// Note that the blog post above clearly states that "Nor should it be applied at the type level if the type being generated is a partial class."
        /// and since our models are partial classes, we have to apply the attribute against the individual members, not the class itself.
        /// </remarks>
        private void WriteGeneratedCodeAttribute()
        {
            WriteLine($"[{typeof(GeneratedCodeAttribute).FullName}(\"{_name}\", \"{_version}\")]");
        }
    }
}